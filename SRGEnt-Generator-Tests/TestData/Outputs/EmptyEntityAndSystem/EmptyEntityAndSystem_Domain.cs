// This file have been generated by SRGEnt-Generator
using System;
using System.Collections.Generic;
using SRGEnt.Interfaces;
using SRGEnt.Groups;
using SRGEnt.Aspects;
using System.Diagnostics;

namespace SRGEnt.Generated
{
    public partial class TestDomain : IEntityDomain<TestEntity, TestDomain, TestMatcher, TestAspectSetter>
    {
        private long _entitiesCreated;
        private readonly HashSet<TestEntity> _destroyedEntities;
        private readonly Dictionary<TestMatcher, CachingEntityGroup<TestEntity>> _cachingEntityGroups;
        private readonly Dictionary<TestMatcher, ReactiveEntityGroup<TestEntity>> _reactiveEntityGroups;
        private Aspect[] _aspects;
        private TestEntity[] _entities;
        public int CurrentCapacity { get; private set; }

        public int CurrentEntityCount { get; private set; }

        public ReadOnlySpan<TestEntity> Entities => CurrentEntityCount > 0 ? new ReadOnlySpan<TestEntity>(_entities).Slice(0, CurrentEntityCount) : ReadOnlySpan<TestEntity>.Empty;
        public TestMatcher GetMatcher() => new();
        public TestDomain(int initialEntityCapacity)
        {
            Debug.Assert(initialEntityCapacity > 0, "Trying to create TestDomain instance with initial capacity less than one.");
            CurrentCapacity = initialEntityCapacity;
            CurrentEntityCount = 0;
            _entitiesCreated = 0;
            _entities = new TestEntity[CurrentCapacity];
            _aspects = new Aspect[CurrentCapacity];
            _destroyedEntities = new HashSet<TestEntity>();
            _cachingEntityGroups = new Dictionary<TestMatcher, CachingEntityGroup<TestEntity>>();
            _reactiveEntityGroups = new Dictionary<TestMatcher, ReactiveEntityGroup<TestEntity>>();
            //ConstructorExtensionLateHook();
        }

        //private partial void ConstructorExtensionLateHook();
        public TestEntity CreateEntity()
        {
            if (CurrentEntityCount + 1 >= CurrentCapacity)
            {
                DoubleCapacity();
            }

            var entity = new TestEntity(this, CurrentEntityCount++, ++_entitiesCreated);
            _entities[entity.Index] = entity;
            _aspects[entity.Index] = CreateAspect();
            //CreateEntityExtensionLateHook(entity);
            return entity;
        }

        //private partial void CreateEntityExtensionLateHook(TestEntity entity);

        private void DoubleCapacity()
        {
            //Double Capacity
            var newCapacity = CurrentCapacity * 2;
            var newEntities = new TestEntity[newCapacity];
            _entities.CopyTo(newEntities, 0);
            _entities = newEntities;
            var newAspects = new Aspect[newCapacity];
            _aspects.CopyTo(newAspects, 0);
            _aspects = newAspects;
            CurrentCapacity = newCapacity;
        }

        public void CleanupEntities()
        {
            if (_destroyedEntities.Count == 0)
                return;
            var entities = new TestEntity[_destroyedEntities.Count];
            _destroyedEntities.CopyTo(entities);
            Array.Sort(entities, (a, b) => b.Index.CompareTo(a.Index));
            foreach (var entity in entities)
            {
                var index = entity.Index;
                CurrentEntityCount--;
                if (index == CurrentEntityCount)
                {
                    _entities[CurrentEntityCount] = default;
                    _aspects[CurrentEntityCount] = default;
                }
                else
                {
                    _entities[index] = new TestEntity(this, index, _entities[CurrentEntityCount].UId);
                    _aspects[index] = _aspects[CurrentEntityCount];
                    _entities[CurrentEntityCount] = default;
                    _aspects[CurrentEntityCount] = default;
                    ShiftComponents((int)CurrentEntityCount, (int)index);
                    UpdateCachingGroupsWithMovedEntity(_entities[index]);
                    UpdateReactiveGroupsWithMovedEntity(_entities[index]);
                    //EntityMovedExtensionLateHook(index);
                }

                //EntityRemovedExtensionLateHook(entity);
            }

            _destroyedEntities.Clear();
        }

        //private partial void EntityMovedExtensionLateHook(int index);
        //private partial void EntityRemovedExtensionLateHook(TestEntity entity);
        private void ShiftComponents(int from, int to)
        {
        }

        public bool HasEntityBeenDestroyed(TestEntity entity) => CurrentEntityCount <= entity.Index && !_entities[entity.Index].Equals(entity);
        public void FlagForDestruction(TestEntity entity)
        {
            if (_destroyedEntities.Contains(entity) || HasEntityBeenDestroyed(entity))
                return;
            _entities[entity.Index] = new TestEntity(this, 0, entity.UId);
            _destroyedEntities.Add(entity);
            UpdateCachingGroupsWithDestroyedEntity(_entities[entity.Index]);
            UpdateReactiveGroupsWithDestroyedEntity(_entities[entity.Index]);
        }

#region Aspects
        public Aspect CreateAspect() => new(TestEntity.AspectSize);
        public Aspect GetEntityAspect(TestEntity entity) => HasEntityBeenDestroyed(entity) ? default : _aspects[entity.Index];
        private void SetAspect(TestEntity entity, AspectIndex index)
        {
            _aspects[entity.Index].Set(index);
            UpdateCachingGroupsWithChangedAspect(entity);
            UpdateReactiveGroupsWithChangedAspect(entity);
        }

        private void RemoveAspect(TestEntity entity, AspectIndex index)
        {
            _aspects[entity.Index].Remove(index);
            UpdateCachingGroupsWithChangedAspect(entity);
            UpdateReactiveGroupsWithChangedAspect(entity);
        }

#endregion
#region Groups
        public EntityGroup<TestEntity, TestDomain, TestMatcher, TestAspectSetter> GetEntityGroup(TestMatcher matcher)
        {
            return new(matcher, this);
        }

        public CachingEntityGroup<TestEntity> GetCachingGroup(TestMatcher matcher, bool shouldSort)
        {
            matcher.RecalculateHash();
            if (_cachingEntityGroups.ContainsKey(matcher))
                return _cachingEntityGroups[matcher];
            var group = new CachingEntityGroup<TestEntity>(matcher, Entities, shouldSort);
            _cachingEntityGroups.Add(matcher, group);
            return group;
        }

        public ReactiveEntityGroup<TestEntity> GetReactiveGroup(TestMatcher matcher, bool shouldSort)
        {
            matcher.RecalculateHash();
            if (_reactiveEntityGroups.ContainsKey(matcher))
                return _reactiveEntityGroups[matcher];
            var group = new ReactiveEntityGroup<TestEntity>(matcher, shouldSort);
            _reactiveEntityGroups.Add(matcher, group);
            return group;
        }

        private void UpdateCachingGroupsWithChangedAspect(TestEntity entity)
        {
            foreach (var entityGroup in _cachingEntityGroups)
            {
                entityGroup.Value.EntityAspectChanged(entity);
            }
        }

        private void UpdateReactiveGroupsWithChangedAspect(TestEntity entity)
        {
            foreach (var entityGroup in _reactiveEntityGroups)
            {
                entityGroup.Value.EntityAspectChanged(entity);
            }
        }

        private void UpdateCachingGroupsWithMovedEntity(TestEntity entity)
        {
            foreach (var entityGroup in _cachingEntityGroups)
            {
                entityGroup.Value.EntityMoved(entity);
            }
        }

        private void UpdateReactiveGroupsWithMovedEntity(TestEntity entity)
        {
            foreach (var entityGroup in _reactiveEntityGroups)
            {
                entityGroup.Value.EntityMoved(entity);
            }
        }

        private void UpdateCachingGroupsWithDestroyedEntity(TestEntity entity)
        {
            foreach (var entityGroup in _cachingEntityGroups)
            {
                entityGroup.Value.EntityDestroyed(entity);
            }
        }

        private void UpdateReactiveGroupsWithDestroyedEntity(TestEntity entity)
        {
            foreach (var entityGroup in _reactiveEntityGroups)
            {
                entityGroup.Value.EntityDestroyed(entity);
            }
        }

        private void UpdateCachingGroupsWithValueChangedEntity(TestEntity entity)
        {
            foreach (var entityGroup in _cachingEntityGroups)
            {
                entityGroup.Value.EntityValueChanged(entity);
            }
        }

        private void UpdateReactiveGroupsWithValueChangedEntity(TestEntity entity)
        {
            foreach (var entityGroup in _reactiveEntityGroups)
            {
                entityGroup.Value.EntityValueChanged(entity);
            }
        }

#endregion
        public void TriggerEvent()
        {
        }
        
    }
}