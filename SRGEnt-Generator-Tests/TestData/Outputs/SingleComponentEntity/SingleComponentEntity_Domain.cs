// This file have been generated by SRGEnt-Generator
using System;
using System.Collections.Generic;
using SRGEnt.Interfaces;
using SRGEnt.Groups;
using SRGEnt.Aspects;
using System.Diagnostics;

namespace SRGEnt.Generated
{
    public partial class SingleComponentTestDomain : IEntityDomain<SingleComponentTestEntity, SingleComponentTestDomain, SingleComponentTestMatcher, SingleComponentTestAspectSetter>
    {
        private long _entitiesCreated;
        private readonly HashSet<SingleComponentTestEntity> _destroyedEntities;
        private readonly Dictionary<SingleComponentTestMatcher, CachingEntityGroup<SingleComponentTestEntity>> _cachingEntityGroups;
        private readonly Dictionary<SingleComponentTestMatcher, ReactiveEntityGroup<SingleComponentTestEntity>> _reactiveEntityGroups;
        private Aspect[] _aspects;
        private SingleComponentTestEntity[] _entities;
        public int CurrentCapacity { get; private set; }

        public int CurrentEntityCount { get; private set; }

        public ReadOnlySpan<SingleComponentTestEntity> Entities => CurrentEntityCount > 0 ? new ReadOnlySpan<SingleComponentTestEntity>(_entities).Slice(0, CurrentEntityCount) : ReadOnlySpan<SingleComponentTestEntity>.Empty;
        public SingleComponentTestMatcher GetMatcher() => new();
        private int[] _firstComponentComponents;
        public SingleComponentTestDomain(int initialEntityCapacity)
        {
            Debug.Assert(initialEntityCapacity > 0, "Trying to create SingleComponentTestDomain instance with initial capacity less than one.");
            CurrentCapacity = initialEntityCapacity;
            CurrentEntityCount = 0;
            _entitiesCreated = 0;
            _entities = new SingleComponentTestEntity[CurrentCapacity];
            _aspects = new Aspect[CurrentCapacity];
            _firstComponentComponents = new int[CurrentCapacity];
            _destroyedEntities = new HashSet<SingleComponentTestEntity>();
            _cachingEntityGroups = new Dictionary<SingleComponentTestMatcher, CachingEntityGroup<SingleComponentTestEntity>>();
            _reactiveEntityGroups = new Dictionary<SingleComponentTestMatcher, ReactiveEntityGroup<SingleComponentTestEntity>>();
            //ConstructorExtensionLateHook();
        }

        //private partial void ConstructorExtensionLateHook();
        public SingleComponentTestEntity CreateEntity()
        {
            if (CurrentEntityCount + 1 >= CurrentCapacity)
            {
                DoubleCapacity();
            }

            var entity = new SingleComponentTestEntity(this, CurrentEntityCount++, ++_entitiesCreated);
            _entities[entity.Index] = entity;
            _aspects[entity.Index] = CreateAspect();
            //CreateEntityExtensionLateHook(entity);
            return entity;
        }

        //private partial void CreateEntityExtensionLateHook(SingleComponentTestEntity entity);
        private void DoubleCapacity()
        {
            //Double Capacity
            var newCapacity = CurrentCapacity * 2;
            var newEntities = new SingleComponentTestEntity[newCapacity];
            _entities.CopyTo(newEntities, 0);
            _entities = newEntities;
            var newAspects = new Aspect[newCapacity];
            _aspects.CopyTo(newAspects, 0);
            _aspects = newAspects;
            var newFirstComponent = new int[newCapacity];
            _firstComponentComponents.CopyTo(newFirstComponent, 0);
            _firstComponentComponents = newFirstComponent;
            CurrentCapacity = newCapacity;
        }

        public void CleanupEntities()
        {
            if (_destroyedEntities.Count == 0)
                return;
            var entities = new SingleComponentTestEntity[_destroyedEntities.Count];
            _destroyedEntities.CopyTo(entities);
            Array.Sort(entities, (a, b) => b.Index.CompareTo(a.Index));
            foreach (var entity in entities)
            {
                var index = entity.Index;
                CurrentEntityCount--;
                if (index == CurrentEntityCount)
                {
                    _entities[CurrentEntityCount] = default;
                    _aspects[CurrentEntityCount] = default;
                }
                else
                {
                    _entities[index] = new SingleComponentTestEntity(this, index, _entities[CurrentEntityCount].UId);
                    _aspects[index] = _aspects[CurrentEntityCount];
                    _entities[CurrentEntityCount] = default;
                    _aspects[CurrentEntityCount] = default;
                    ShiftComponents((int)CurrentEntityCount, (int)index);
                    UpdateCachingGroupsWithMovedEntity(_entities[index]);
                    UpdateReactiveGroupsWithMovedEntity(_entities[index]);
                    //EntityMovedExtensionLateHook(index);
                }

                //EntityRemovedExtensionLateHook(entity);
            }

            _destroyedEntities.Clear();
        }

        //private partial void EntityMovedExtensionLateHook(int index);
        //private partial void EntityRemovedExtensionLateHook(SingleComponentTestEntity entity);
        private void ShiftComponents(int from, int to)
        {
            _firstComponentComponents[to] = _firstComponentComponents[from];
            _firstComponentComponents[from] = default;
        }

        public bool HasEntityBeenDestroyed(SingleComponentTestEntity entity) => CurrentEntityCount <= entity.Index && !_entities[entity.Index].Equals(entity);
        public void FlagForDestruction(SingleComponentTestEntity entity)
        {
            if (_destroyedEntities.Contains(entity) || HasEntityBeenDestroyed(entity))
                return;
            _entities[entity.Index] = new SingleComponentTestEntity(this, 0, entity.UId);
            _destroyedEntities.Add(entity);
            UpdateCachingGroupsWithDestroyedEntity(_entities[entity.Index]);
            UpdateReactiveGroupsWithDestroyedEntity(_entities[entity.Index]);
        }

#region Aspects
        public Aspect CreateAspect() => new(SingleComponentTestEntity.AspectSize);
        public Aspect GetEntityAspect(SingleComponentTestEntity entity) => HasEntityBeenDestroyed(entity) ? default : _aspects[entity.Index];
        private void SetAspect(SingleComponentTestEntity entity, AspectIndex index)
        {
            _aspects[entity.Index].Set(index);
            UpdateCachingGroupsWithChangedAspect(entity);
            UpdateReactiveGroupsWithChangedAspect(entity);
        }

        private void RemoveAspect(SingleComponentTestEntity entity, AspectIndex index)
        {
            _aspects[entity.Index].Remove(index);
            UpdateCachingGroupsWithChangedAspect(entity);
            UpdateReactiveGroupsWithChangedAspect(entity);
        }

#endregion
#region Groups
        public EntityGroup<SingleComponentTestEntity, SingleComponentTestDomain, SingleComponentTestMatcher, SingleComponentTestAspectSetter> GetEntityGroup(SingleComponentTestMatcher matcher)
        {
            return new(matcher, this);
        }

        public CachingEntityGroup<SingleComponentTestEntity> GetCachingGroup(SingleComponentTestMatcher matcher, bool shouldSort)
        {
            matcher.RecalculateHash();
            if (_cachingEntityGroups.ContainsKey(matcher))
                return _cachingEntityGroups[matcher];
            var group = new CachingEntityGroup<SingleComponentTestEntity>(matcher, Entities, shouldSort);
            _cachingEntityGroups.Add(matcher, group);
            return group;
        }

        public ReactiveEntityGroup<SingleComponentTestEntity> GetReactiveGroup(SingleComponentTestMatcher matcher, bool shouldSort)
        {
            matcher.RecalculateHash();
            if (_reactiveEntityGroups.ContainsKey(matcher))
                return _reactiveEntityGroups[matcher];
            var group = new ReactiveEntityGroup<SingleComponentTestEntity>(matcher, shouldSort);
            _reactiveEntityGroups.Add(matcher, group);
            return group;
        }

        private void UpdateCachingGroupsWithChangedAspect(SingleComponentTestEntity entity)
        {
            foreach (var entityGroup in _cachingEntityGroups)
            {
                entityGroup.Value.EntityAspectChanged(entity);
            }
        }

        private void UpdateReactiveGroupsWithChangedAspect(SingleComponentTestEntity entity)
        {
            foreach (var entityGroup in _reactiveEntityGroups)
            {
                entityGroup.Value.EntityAspectChanged(entity);
            }
        }

        private void UpdateCachingGroupsWithMovedEntity(SingleComponentTestEntity entity)
        {
            foreach (var entityGroup in _cachingEntityGroups)
            {
                entityGroup.Value.EntityMoved(entity);
            }
        }

        private void UpdateReactiveGroupsWithMovedEntity(SingleComponentTestEntity entity)
        {
            foreach (var entityGroup in _reactiveEntityGroups)
            {
                entityGroup.Value.EntityMoved(entity);
            }
        }

        private void UpdateCachingGroupsWithDestroyedEntity(SingleComponentTestEntity entity)
        {
            foreach (var entityGroup in _cachingEntityGroups)
            {
                entityGroup.Value.EntityDestroyed(entity);
            }
        }

        private void UpdateReactiveGroupsWithDestroyedEntity(SingleComponentTestEntity entity)
        {
            foreach (var entityGroup in _reactiveEntityGroups)
            {
                entityGroup.Value.EntityDestroyed(entity);
            }
        }

        private void UpdateCachingGroupsWithValueChangedEntity(SingleComponentTestEntity entity)
        {
            foreach (var entityGroup in _cachingEntityGroups)
            {
                entityGroup.Value.EntityValueChanged(entity);
            }
        }

        private void UpdateReactiveGroupsWithValueChangedEntity(SingleComponentTestEntity entity)
        {
            foreach (var entityGroup in _reactiveEntityGroups)
            {
                entityGroup.Value.EntityValueChanged(entity);
            }
        }

#endregion
        public bool HasFirstComponent(SingleComponentTestEntity entity) => _aspects[entity.Index].ContainsComponent(SingleComponentTestEntity.FIRSTCOMPONENT_INDEX);
        public int GetFirstComponent(SingleComponentTestEntity entity)
        {
            if (!HasEntityBeenDestroyed(entity) && HasFirstComponent(entity))
                return _firstComponentComponents[entity.Index];
            throw new InvalidOperationException();
        }

        public void AddFirstComponent(SingleComponentTestEntity entity, in int value)
        {
            if (HasEntityBeenDestroyed(entity) || HasFirstComponent(entity))
                throw new InvalidOperationException();
            SetAspect(entity, SingleComponentTestEntity.FIRSTCOMPONENT_INDEX);
            _firstComponentComponents[entity.Index] = value;
        }

        public void ReplaceFirstComponent(SingleComponentTestEntity entity, in int value)
        {
            if (HasEntityBeenDestroyed(entity) || !HasFirstComponent(entity))
                throw new InvalidOperationException();
            _firstComponentComponents[entity.Index] = value;
            UpdateCachingGroupsWithValueChangedEntity(entity);
            UpdateReactiveGroupsWithValueChangedEntity(entity);
        }

        public void RemoveFirstComponent(SingleComponentTestEntity entity)
        {
            if (HasEntityBeenDestroyed(entity) || !HasFirstComponent(entity))
                throw new InvalidOperationException();
            RemoveAspect(entity, SingleComponentTestEntity.FIRSTCOMPONENT_INDEX);
            _firstComponentComponents[entity.Index] = default;
        }

        public void TriggerEvent()
        {
        }
    }
}